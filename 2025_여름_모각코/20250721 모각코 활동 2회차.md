오늘의 목표
1.데이터 표현(정수, 실수, 문자) 이해하기
2.산술 연산을 위한 회로 설계 공부
# 데이터 표현과 산술 연산

## 1. 정수 표현

### 부호 없는 정수 (Unsigned Integer)

**특징**
- 0 이상의 양수만 표현
- n비트로 0부터 2ⁿ-1까지 표현 가능
- 모든 비트가 크기를 나타냄
- 예시
	- 0000₂ = 0₁₀
	- 0101₂ = 5₁₀
	- 1111₂ = 15₁₀

### 부호 있는 정수 (Signed Integer)

#### 부호-크기 표현 (Sign-Magnitude)

- 최상위 비트(MSB)가 부호 비트 (0=양수, 1=음수)
- 나머지 비트가 크기를 나타냄
- 문제점 : 0이 두 개 (+0, -0), 연산이 복잡
- 예시 (4비트)
	- 0011₂ = +3₁₀
	- 1011₂ = -3₁₀

#### 1의 보수 (One's Complement)

- 양수의 모든 비트를 반전시켜 음수 표현
- 문제점 : 여전히 0이 두 개 존재
- 예시
	- +3: 0011₂
	- -3: 1100₂ (0011의 모든 비트 반전)

#### ==2의 보수 (Two's Complement)==
**현재 가장 널리 사용되는 방식**

**계산 방법**
1. 양수의 1의 보수를 구함 (모든 비트 반전)
2. 1을 더함
- 예시
	- +3: 0011₂
	- -3: 1100₂ + 1₂ = 1101₂
- 0이 하나만 존재
- 덧셈/뺄셈 회로가 동일
- 범위: -2ⁿ⁻¹ ~ 2ⁿ⁻¹-1
- **8비트 2의 보수 범위**: -128 ~ +127

### 오버플로 (Overflow)

표현 가능한 범위를 벗어나는 경우
- **부호 없는 정수**: 자리올림이 발생하면 오버플로
- **부호 있는 정수**: 부호가 바뀌면 오버플로

## 2. 실수 표현

### IEEE 754 표준

**구성 요소**
- **부호(Sign)**: 1비트 (0=양수, 1=음수)
- **지수(Exponent)**: 8비트 (단정도), 11비트 (배정도)
- **가수(Mantissa/Significand)**: 23비트 (단정도), 52비트 (배정도)

### 단정도 (32비트)

**형식**: S EEEEEEEE MMMMMMMMMMMMMMMMMMMMMMM
- **S**: Sign bit (부호 비트) - **1비트**
- **EEEEEEEE**: Exponent (지수) - **8비트**
- **MMMMMMMMMMMMMMMMMMMMMMM**: Mantissa/Significand (가수) - **23비트**

**표현 방법**
1. 실수를 이진 소수로 변환
2. 정규화 (1.xxxxx × 2ᵏ 형태)
3. 지수에 바이어스(127) 더함
4. 가수에서 정수부 1 제거 (암묵적 1)
- 예시: 12.75₁₀ 표현
	1. 12.75₁₀ = 1100.11₂
	2. 정규화: 1.10011 × 2³
	3. 지수: 3 + 127 = 130₁₀ = 10000010₂
	4. 가수: 10011000000000000000000₂
	5. 결과: 0 10000010 10011000000000000000000

### 특수값

- **0**: 지수와 가수가 모두 0
- **무한대(∞)**: 지수가 모두 1, 가수가 0
- **NaN**: 지수가 모두 1, 가수가 0이 아님

### 정밀도 한계

- 모든 실수를 정확히 표현할 수 없음
- 반올림 오차 발생 가능
- 예: 0.1₁₀을 이진수로 정확히 표현 불가

## 3. 문자 표현 (Character Representation)

### ASCII (American Standard Code for Information Interchange)

**특징**
- 7비트 코드 (0~127)
- 128개 문자 표현
- 영어 알파벳, 숫자, 특수문자, 제어문자

**주요 코드**
- '0' ~ '9': 48 ~ 57 (30H ~ 39H)
- 'A' ~ 'Z': 65 ~ 90 (41H ~ 5AH)
- 'a' ~ 'z': 97 ~ 122 (61H ~ 7AH)
- 공백: 32 (20H)
- 줄바꿈(LF): 10 (0AH)

**확장 ASCII**
- 8비트 사용 (0~255)
- 추가 128개 문자 (특수문자, 외국어 문자)

### Unicode

**배경**
- ASCII로는 전 세계 모든 문자 표현 불가
- 다국어 지원 필요

**특징**
- 전 세계 모든 문자를 하나의 코드 체계로 통합
- 현재 약 150,000개 문자 수록
- 코드 포인트: U+0000 ~ U+10FFFF

**인코딩 방식**
- **UTF-8**: 가변 길이 (1~4바이트), ASCII 호환
- **UTF-16**: 가변 길이 (2~4바이트)
- **UTF-32**: 고정 길이 (4바이트)

**UTF-8의 장점**
- ASCII와 완전 호환
- 인터넷에서 가장 널리 사용
- 영어는 1바이트, 한글은 3바이트로 효율적

## 4. 산술 논리 장치 (ALU)

### ALU의 역할
- CPU의 핵심 구성 요소
- 산술 연산(+, -, ×, ÷)과 논리 연산(AND, OR, NOT) 수행
- 비교 연산과 시프트 연산도 담당

### ALU 구조

**입력**
- A, B: 피연산자 (보통 32비트 또는 64비트)
- 제어 신호: 수행할 연산 지정
- 캐리 입력(Cin): 이전 연산의 자리올림

**출력**
- 결과(Result): 연산 결과
- 플래그(Flags): 연산 상태 정보
    - Zero Flag (Z): 결과가 0일 때
    - Carry Flag (C): 자리올림 발생 시
    - Overflow Flag (V): 오버플로 발생 시
    - Negative Flag (N): 결과가 음수일 때

### ALU 제어

**제어 신호 예시** (4비트)
- 0000: A AND B
- 0001: A OR B
- 0010: A + B
- 0110: A - B
- 0111: A < B인지 비교

## 5. 덧셈기 회로 설계

### 반가산기 (Half Adder)

**기능**: 2개의 1비트 수를 더함 **입력**: A, B **출력**: Sum, Carry

**논리식**
- Sum = A ⊕ B (XOR)
- Carry = A · B (AND)

**진리표**

| A   | B   | Sum | Carry |
| --- | --- | --- | ----- |
| 0   | 0   | 0   | 0     |
| 0   | 1   | 1   | 0     |
| 1   | 0   | 1   | 0     |
| 1   | 1   | 0   | 1     |

### 전가산기 (Full Adder)

**기능**: 2개의 1비트 수와 이전 자리올림을 더함 **입력**: A, B, Cin **출력**: Sum, Cout

**논리식**
- Sum = A ⊕ B ⊕ Cin
- Cout = A·B + Cin·(A ⊕ B)

**구현 방법**
- 반가산기 2개를 연결하여 구성 가능


## 6. 뺄셈기 회로 설계

### 2의 보수를 이용한 뺄셈

**원리**: A - B = A + (-B) = A + B의 2의 보수

**구현 방법**
1. B의 모든 비트를 반전 (1의 보수)
2. 가산기의 캐리 입력에 1을 넣음
3. A와 처리된 B를 가산기로 더함

**장점**
- 덧셈기 회로를 그대로 활용
- 별도의 뺄셈 회로 불필요

### 가감산기 (Adder-Subtractor)

**구조**
- 덧셈기에 XOR 게이트 추가
- 제어 신호로 덧셈/뺄셈 선택

**동작**
- Sub = 0: 덧셈 모드 (B는 그대로 전달)
- Sub = 1: 뺄셈 모드 (B는 반전되어 전달, Cin = 1)

## 7. 곱셈과 나눗셈

### 곱셈 알고리즘

**시프트-덧셈 방법**
1. 승수의 각 비트를 검사
2. 1이면 피승수를 더하고, 0이면 건너뜀
3. 매번 피승수를 왼쪽으로 시프트

**부스 알고리즘 (Booth's Algorithm)**
- 부호 있는 정수의 효율적인 곱셈
- 연속된 1을 하나의 덧셈과 뺄셈으로 처리

### 나눗셈 알고리즘

**복원 나눗셈 (Restoring Division)**
1. 피제수에서 제수를 빼봄
2. 결과가 음수면 복원하고 몫에 0
3. 결과가 양수면 몫에 1
4. 나머지를 왼쪽으로 시프트하고 반복
