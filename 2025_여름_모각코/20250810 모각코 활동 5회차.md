오늘의 목표 : 저번에 공부하던 캐시 부분 이어서 더 공부하기, 파이프라인 개념 공부하기 
# 캐시와 파이프라인

## 1. 그래서 캐시는...

### 캐시는 언제 쓰는건가?
- 자주 쓰는 데이터가 있어서, 이걸 임시로 저장해두고 우다다 쓰고 싶을 때.
- 캐시 없는 상황에서의 명령어 실행은?
	- CPU의 대부분의 시간이 메모리를 기다리는 시간일 것이다( 명령어 가져오고(= 메모리 접근) 해석하고 실행하고 또 메모리접근해서 결과저장 ... )

## 2. 파이프라인
파이프라인이란? -> 캐시 성능을 극대화 하기 위한 CPU 설계 기법 : 동시에 일을 하게 시키는 것임

### 일반적인 순차 처리
일1, 일2, 일3
시간1 -> 일1 시작하자
시간2 -> 일1 끝났다! 일2 시작하자
시간3 -> 일2 끝났다!, 일3 시작하자
시간4 -> 일3 끝났다!

### 파이프라인 처리 ( 병렬 처리 )
일1, 일2, 일3
시간1 -> 일1 시작하자,
시간1~ -> 일2 시작하자, 일1 하는중
시간1~ -> 일3 시작하자,  일2 하는중, 일1 끝났다.
시간2 -> 일3 하는중, 일2 끝났다.
시간2~ -> 일3 끝났다.

```
1. IF (Instruction Fetch): 명령어 가져오기
2. ID (Instruction Decode): 명령어 해석 + 레지스터 읽기
3. EX (Execute): ALU 연산 또는 주소 계산
4. MEM (Memory): 메모리 접근 (lw/sw만)
5. WB (Write Back): 결과를 레지스터에 저장
```
- **IF 단계**: 명령어 캐시 접근
- **MEM 단계**: 메모리 접근 없음
- -> 따라서 캐시의 미스가 영향을 미치는 부분은 IF에서만...

### 파이프라인의 문제점
- 데이터 해저드 - 앞의 결과를 뒤에서 바로 써야 할 때
	- STALL, FORWARDING으로 해결가능
	- STALL:  뒤의 일을 잠시 대기시켰다가 앞에서 결과를 받고 그대로 사용
	- FORWARDING : MEM의 결과를 바로 EX로 전달하기
- 제어 해저드 - 분기할지 말지 모르겠을 때.
	- 분기 결과를 알려면 **EX 단계**까지 가야하는데, 다음 명령어는 **IF 단계**에서 미리 가져와야 함. 근데?? 어떤 명령어를 가져올지 모르겠어!
	- 항상 분기 안한다고 가정해서 순차적으로 계속 가져오거나 분기 예측기로 과거 패턴을 보고 예측하는 방식으로 해결

## 캐시와 파이프라인의 상호작용
### 명령어별 캐시 접근

#### R-type 명령어 (add, sub, and, or, ...)
```assembly
add $t0, $t1, $t2
```
- **IF**: 명령어 캐시 접근 (히트/미스 가능)
- **MEM**: 메모리 접근 없음 (캐시 무관)
- **영향**: IF에서 캐시 미스 시만 스톨
#### Load 명령어 (lw)
```assembly
lw $t0, 4($s0)
```
- **IF**: 명령어 캐시 접근
- **MEM**: 데이터 캐시 접근
- **영향**: 두 번의 캐시 접근! 둘 다 미스 가능성
#### Store 명령어 (sw)
```assembly
sw $t0, 4($s0)
```
- **IF**: 명령어 캐시 접근
- **MEM**: 데이터 캐시 쓰기
- **특이점**: Write 정책에 따라 다름