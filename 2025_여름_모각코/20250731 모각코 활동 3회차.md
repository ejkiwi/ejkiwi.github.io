오늘의 목표 : 프로세서 기초와 명령어 집합 공부하기

# 프로세서 기초와 명령어 집합 
일단 컴퓨터의 구조이다

## 1. CPU 기본 구조

### CPU의 핵심 구성 요소 
![cpu](https://ejkiwi.github.io/lib/media/cpu.png)
제어장치가 시키고, 연산장치가 일하고, 레지스터가 저장하는 느낌이다`~_~`
### 제어장치 (Control Unit)
**역할**
- ==명령어를 해석하고 실행 순서를 제어==
- 각 구성 요소에 제어 신호 전송
- 프로그램 카운터(PC) 관리
**주요 기능**
- **명령어 인출 (Fetch)**: 메모리에서 명령어 가져오기
- **명령어 해석 (Decode)**: 명령어의 의미 분석
- **실행 제어 (Execute)**: 필요한 제어 신호 생성
**구성 요소**
- **프로그램 카운터 (PC)**: 다음 실행할 **명령어의 주소** 저장
- **명령어 레지스터 (IR)**: 현재 실행 중인 **명령어** 저장
- **제어 신호 생성기**: 각 구성 요소 제어

### 연산장치 (ALU, Arithmetic Logic Unit)
**역할**
- 모든 ==산술 연산과 논리 연산 수행==
- 비교 연산 및 시프트 연산 담당
**지원 연산**
- **산술 연산**: 덧셈, 뺄셈, 곱셈, 나눗셈
- **논리 연산**: AND, OR, XOR, NOT
- **비교 연산**: 같음, 크기 비교
- **시프트 연산**: 좌시프트, 우시프트
**플래그 레지스터**
- **Zero Flag (Z)**: 결과가 0인지 표시
- **Carry Flag (C)**: 자리올림 발생 시
- **Overflow Flag (V)**: 오버플로 발생 시
- **Negative Flag (N)**: 결과가 음수인지 표시

### 레지스터 (Register)
**역할**
- ==CPU에서 당장 사용할 데이터 보관==
**특징**
- CPU 내부의 고속 저장 공간
- 메모리보다 훨씬 빠른 접근 속도
- 제한된 개수 (보통 16~32개)
**종류**
- **범용 레지스터**: 일반적인 데이터 저장
- **특수 목적 레지스터**: 특정 용도로 사용
    - PC (Program Counter): 다음 명령어 주소
    - SP (Stack Pointer): 스택의 최상위 주소
    - LR (Link Register): 함수 호출 시 복귀 주소

## 2. 명령어 집합 구조 (ISA, Instruction Set Architecture)

### ISA의 개념
**정의**
- 소프트웨어와 하드웨어 간의 인터페이스
- 프로그래머가 볼 수 있는 컴퓨터의 추상적 모델
- CPU가 이해할 수 있는 명령어들의 집합
**ISA가 정의하는 요소**
- **명령어 집합**: 사용 가능한 모든 명령어
- **레지스터**: 개수, 크기, 용도
- **메모리 모델**: 주소 지정 방식, 데이터 타입
- **예외 처리**: 인터럽트, 예외 상황 처리

## 3. RISC-V 명령어 세트

### RISC-V 개요
**특징**
- 오픈소스 ISA
- 모듈러 설계 (기본 + 확장)
- 학술 및 상업적 목적으로 자유 사용

### RISC-V 레지스터
**32개의 범용 레지스터 (x0 ~ x31)**

|레지스터|ABI 이름|용도|보존 여부|
|---|---|---|---|
|x0|zero|항상 0|-|
|x1|ra|복귀 주소|호출자|
|x2|sp|스택 포인터|피호출자|
|x3|gp|글로벌 포인터|-|
|x4|tp|쓰레드 포인터|-|
|x5-x7|t0-t2|임시 레지스터|호출자|
|x8|s0/fp|저장/프레임 포인터|피호출자|
|x9|s1|저장 레지스터|피호출자|
|x10-x11|a0-a1|인수/반환값|호출자|
|x12-x17|a2-a7|인수 레지스터|호출자|
|x18-x27|s2-s11|저장 레지스터|피호출자|
|x28-x31|t3-t6|임시 레지스터|호출자|

**특수 레지스터**
- **x0 (zero)**: 항상 0 값, 쓰기 무시
- **pc**: 프로그램 카운터 (명시적 접근 불가)

## 4. 명령어 형식 (Instruction Format)

### R-type (Register Type)

**용도**: 레지스터 간 연산 **형식**: `op rd, rs1, rs2`


### I-type (Immediate Type)

**용도**: 즉시값과 레지스터 연산, 로드 명령어 **형식**: `op rd, rs1, imm` 또는 `op rd, imm(rs1)`


### S-type (Store Type)

**용도**: 스토어 명령어 **형식**: `op rs2, imm(rs1)`


### B-type (Branch Type)

**용도**: 조건부 분기 **형식**: `op rs1, rs2, label`


### U-type (Upper Immediate Type)

**용도**: 상위 즉시값 로드 **형식**: `op rd, imm`


### J-type (Jump Type)

**용도**: 무조건 점프 **형식**: `op rd, label`



## 5. 주소 지정 방식 (Addressing Modes)

### 즉시 주소 지정 (Immediate Addressing)
**형식**: `addi x1, x2, 100`
**의미**: 즉시값을 직접 사용
**장점**: 빠름
**단점**: 값의 크기 제한

### 레지스터 주소 지정 (Register Addressing)
**형식**: `add x1, x2, x3` 
**의미**: 레지스터 값 직접 사용
**장점**: 가장 빠름 
**특징**: RISC의 기본 방식

### 베이스 + 오프셋 주소 지정 (Base + Displacement)
**형식**: `lw x1, 8(x2)` 
**의미**: 베이스 레지스터 + 오프셋 
**용도**: 배열, 구조체 접근 
**계산**: 주소 = x2 + 8

### PC 상대 주소 지정 (PC-relative)
**형식**: `beq x1, x2, label`
**의미**: 현재 PC + 오프셋 
**용도**: 분기 명령어 
**장점**: 위치 독립적 코드

## 6. 명령어 실행 과정

### 기본 실행 사이클

**1. 인출 (Fetch)**

```
IR ← Memory[PC]
PC ← PC + 4
```

**2. 해석 (Decode)**

- 명령어 형식 판별
- 필요한 레지스터 식별
- 제어 신호 생성

**3. 실행 (Execute)**

- ALU 연산 수행
- 메모리 접근 (필요시)
- 결과 저장

**4. 쓰기 (Write-back)**

- 결과를 목적지 레지스터에 저장
- 플래그 업데이트

### 예시: `add x1, x2, x3` 실행

```
1. Fetch: IR ← Memory[PC], PC ← PC + 4
2. Decode: R-type, rs1=x2, rs2=x3, rd=x1, funct=ADD
3. Execute: ALU_result ← Register[x2] + Register[x3]
4. Write-back: Register[x1] ← ALU_result
```
