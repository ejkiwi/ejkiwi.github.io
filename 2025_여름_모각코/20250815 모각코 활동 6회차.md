오늘의 목표 : 가상 메모리 공부하기

# 가상 메모리
**프로그램이 실제 RAM보다 큰 메모리 공간을 쓸 수 있게 해주는 기술** (디스크를 메모리처럼 활용)
-> 작은 RAM으로도 큰 프로그램을 실행할 수 있게 해준다!!
## 기본 개념
- 가상 메모리: 물리적 메모리보다 큰 메모리 공간을 프로그램에게 제공하는 기법
- 프로그램이 실제 물리 메모리 크기에 제약받지 않고 실행될 수 있도록 함
- 프로그램은 논리적 주소인 가상 주소를 사용하지만 실제 CPU는 당연히~ 물리적 주소에 접근을 하여야 한다. 이때 물리적 주소와 논리적 주소 사이에 상호 변환이 가능해야 하는데, 변환이 가능한 테이블을 운영체제가 제공해준다.
- 메모리 관리 하드웨어와 운영체제가 협력하여 구현

## 주요 목적
1. **메모리 용량 확장**: 물리 메모리보다 큰 프로그램 실행 가능
2. **메모리 보호**: 프로세스 간 메모리 영역 분리
3. **메모리 공유**: 여러 프로세스가 동일한 코드/데이터 공유 가능
4. **프로그래밍 단순화**: 연속된 메모리 공간 제공

## 주소 변환
### 가상 주소 vs 물리 주소
- **가상 주소(Virtual Address)**: 프로그램이 사용하는 논리적 주소
- **물리 주소(Physical Address)**: 실제 메모리에서의 위치

### 주소 변환 과정
```
가상 주소 → MMU(Memory Management Unit) → 물리 주소
```

### MMU (Memory Management Unit)
- 하드웨어 구성요소
- 가상 주소를 물리 주소로 변환
- 페이지 테이블을 참조하여 변환 수행

## 페이징 시스템
### 페이지와 프레임
- **페이지(Page)**: 가상 메모리를 일정한 크기로 나눈 단위 (보통 4KB)
- **프레임(Frame)**: 물리 메모리를 페이지와 같은 크기로 나눈 단위

### 페이지 테이블
- 가상 페이지 번호 → 물리 프레임 번호 매핑
- 각 프로세스마다 별도의 페이지 테이블 존재

#### 페이지 테이블 엔트리
- **Valid bit**: 해당 페이지가 메모리에 있는지 표시
- **Protection bits**: 읽기/쓰기/실행 권한
- **Reference bit**: 최근에 접근했는지 표시
- **Modify bit**: 페이지가 수정되었는지 표시

## 주소 변환 상세 과정
### 가상 주소 구조 (32비트 시스템 예시)

```
| Page Number (20비트) | Offset (12비트) |
```
1. 가상 주소에서 페이지 번호와 오프셋 추출
2. 페이지 테이블에서 해당 페이지 번호로 프레임 번호 찾기
3. Valid bit 확인
4. 프레임 번호 + 오프셋 → 물리 주소

## 페이지 폴트 

### 페이지 폴트 발생 상황
- 접근하려는 페이지가 물리 메모리에 없을 때
- Valid bit가 0인 페이지에 접근할 때
### 페이지 폴트 처리 과정
1. 하드웨어가 페이지 폴트 예외 발생
2. OS의 페이지 폴트 핸들러 실행
3. 보조 저장장치(디스크)에서 해당 페이지 로드
4. 페이지 테이블 업데이트
5. 프로그램 재실행

## 가상 메모리의 장단점
### 장점
- 물리 메모리보다 큰 프로그램 실행 가능
- 다중 프로그래밍 지원
- 메모리 보호 및 공유 기능
- 프로그래밍 편의성 증대
### 단점
- 주소 변환 오버헤드
- 페이지 폴트로 인한 성능 저하
- 복잡한 메모리 관리

